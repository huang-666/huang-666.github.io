<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Docker | 枯木逢春夏秋冬</title><meta name="keywords" content="Docker"><meta name="author" content="枯木逢春"><meta name="copyright" content="枯木逢春"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker   基础篇    Docker 简介Docker 为什么出现 假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://huang-666.github.io/2022/05/07/Docker/index.html">
<meta property="og:site_name" content="枯木逢春夏秋冬">
<meta property="og:description" content="Docker   基础篇    Docker 简介Docker 为什么出现 假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg">
<meta property="article:published_time" content="2022-05-07T13:40:56.000Z">
<meta property="article:modified_time" content="2022-05-19T16:02:18.820Z">
<meta property="article:author" content="枯木逢春">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg"><link rel="shortcut icon" href="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/favicon.png"><link rel="canonical" href="https://huang-666.github.io/2022/05/07/Docker/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-20 00:02:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/头像.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">枯木逢春夏秋冬</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于博主</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-07T13:40:56.000Z" title="发表于 2022-05-07 21:40:56">2022-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-19T16:02:18.820Z" title="更新于 2022-05-20 00:02:18">2022-05-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><center>Docker</center></h1>

<hr>
<h1><center>基础篇</center></h1>



<h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><h3 id="Docker-为什么出现"><a href="#Docker-为什么出现" class="headerlink" title="Docker 为什么出现"></a>Docker 为什么出现</h3><blockquote>
<p><strong>假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。请问？</strong></p>
<p><strong>您要如何确保应用能够在这些环境中运行和通过质量检测？并且在部署过程中不出现令人头疼的版本、配置问题，也无需重新编写代码和进行故障修复？</strong></p>
<p><strong>答案就是使用容器。Docker 之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案—–系统平滑移植，容器虚拟化技术。</strong></p>
<p><strong>环境配置相当麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/01.png" alt="image-20220505222142843"></p>
<blockquote>
<p><strong>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java&#x2F;RabbitMQ&#x2F;MySQL&#x2F;JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</strong></p>
<p><strong>传统上认为，软件编码开发&#x2F;测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等（java为例）。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker 的出现使得 Docker 得以打破过去「程序即应用」的观念。透过镜像（images）将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></p>
</blockquote>
<h3 id="Docker-理念概念"><a href="#Docker-理念概念" class="headerlink" title="Docker 理念概念"></a>Docker 理念概念</h3><blockquote>
<p><strong>Docker 是基于 Go 语言实现的云开源项目。</strong></p>
<p><strong>Docker 的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP（可以是一个 WEB 应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/02.png" alt="02"></p>
<blockquote>
<p><strong>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在 Docker 容器上面的实例，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</strong></p>
</blockquote>
<h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><blockquote>
<p><strong>解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></p>
</blockquote>
<h3 id="传统虚拟机和容器的对比"><a href="#传统虚拟机和容器的对比" class="headerlink" title="传统虚拟机和容器的对比"></a>传统虚拟机和容器的对比</h3><h4 id="容器发展简史"><a href="#容器发展简史" class="headerlink" title="容器发展简史"></a>容器发展简史</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/03.png" alt="03"></p>
<h4 id="传统虚拟机技术"><a href="#传统虚拟机技术" class="headerlink" title="传统虚拟机技术"></a>传统虚拟机技术</h4><blockquote>
<p><strong>虚拟机（virtual machine）就是带环境安装的一种解决方案。</strong></p>
<p><strong>它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行 Linux 系统 CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</strong>  </p>
</blockquote>
<table>
<thead>
<tr>
<th>Win10</th>
<th>VMWare</th>
<th>Centos7</th>
<th>各种cpu、内存网络额配置+各种软件</th>
<th>虚拟机实例</th>
</tr>
</thead>
</table>
<blockquote>
<p><strong>传统虚拟机技术基于安装在主操作系统上的虚拟机管理（如：VirtualBox 和 VMWare 等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装操作系统，在从操作系统中安装部署各种应用。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/04.png" alt="04"></p>
<h5 id="传统虚拟机的缺点"><a href="#传统虚拟机的缺点" class="headerlink" title="传统虚拟机的缺点"></a>传统虚拟机的缺点</h5><ol>
<li><p><strong>资源占用多</strong></p>
</li>
<li><p><strong>冗余步骤多</strong></p>
</li>
<li><p><strong>启动慢</strong></p>
</li>
</ol>
<h4 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h4><blockquote>
<p><strong>由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：</strong></p>
<p><strong>Linux 容器（Linux Containers，缩写为 LXC）</strong></p>
<p><strong>Linux 容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</strong></p>
<p><strong>Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/05.png" alt="05"></p>
<blockquote>
<p><strong>Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。</strong></p>
</blockquote>
<h3 id="Docker-能干嘛能解决什么问题"><a href="#Docker-能干嘛能解决什么问题" class="headerlink" title="Docker 能干嘛能解决什么问题"></a>Docker 能干嘛能解决什么问题</h3><h4 id="技术职级变化"><a href="#技术职级变化" class="headerlink" title="技术职级变化"></a>技术职级变化</h4><blockquote>
<p><strong>英文：coder→programmer→software engineer→DevOps engineer</strong></p>
<p><strong>翻译：编码器→程序→软件工程师→DevOps工程师</strong></p>
</blockquote>
<h4 id="开发-x2F-运维（DevOps）新一代开发工程师"><a href="#开发-x2F-运维（DevOps）新一代开发工程师" class="headerlink" title="开发&#x2F;运维（DevOps）新一代开发工程师"></a>开发&#x2F;运维（DevOps）新一代开发工程师</h4><blockquote>
<p><strong>一次构建、随处运行</strong></p>
<ul>
<li><strong>更快速的应用交付和部署</strong></li>
<li><strong>更便捷的升级和扩缩容</strong></li>
<li><strong>更简单的系统运维</strong></li>
<li><strong>更高效的计算资源利用</strong></li>
</ul>
</blockquote>
<h4 id="Docker-应用场景"><a href="#Docker-应用场景" class="headerlink" title="Docker 应用场景"></a>Docker 应用场景</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/06.png" alt="06"></p>
<h4 id="哪些企业在使用"><a href="#哪些企业在使用" class="headerlink" title="哪些企业在使用"></a>哪些企业在使用</h4><blockquote>
<ul>
<li><strong>新浪</strong></li>
<li><strong>美团</strong></li>
<li><strong>蘑菇街</strong></li>
</ul>
<p><strong>………..</strong></p>
</blockquote>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><center><strong>注意：我这里使用阿里云服务器进行安装，操作系统为CentOS 7.6 64位</strong></center>



<h3 id="1、操作系统要求"><a href="#1、操作系统要求" class="headerlink" title="1、操作系统要求"></a>1、操作系统要求</h3><blockquote>
<p><strong>要安裝 Docker 引擎，你需要一個維持的 CentOS 7 或 8 版本。不支持或测试存档版本。</strong></p>
</blockquote>
<h3 id="2、卸载旧版本"><a href="#2、卸载旧版本" class="headerlink" title="2、卸载旧版本"></a>2、卸载旧版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>



<h3 id="3、安装gcc相关"><a href="#3、安装gcc相关" class="headerlink" title="3、安装gcc相关"></a>3、安装gcc相关</h3><blockquote>
<p><strong>因为阿里云服务器自带 gcc，所有这里我就无需安装。使用<code>gcc -v</code>命令来查看是否安装了 gcc</strong>。</p>
</blockquote>
<h3 id="4、安装需要的软件包"><a href="#4、安装需要的软件包" class="headerlink" title="4、安装需要的软件包"></a>4、安装需要的软件包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>



<h3 id="5、设置stable镜像仓库"><a href="#5、设置stable镜像仓库" class="headerlink" title="5、设置stable镜像仓库"></a>5、设置stable镜像仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>



<h3 id="6、更新yum软件包索引"><a href="#6、更新yum软件包索引" class="headerlink" title="6、更新yum软件包索引"></a>6、更新yum软件包索引</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>



<h3 id="7、安装DOCKER-CE"><a href="#7、安装DOCKER-CE" class="headerlink" title="7、安装DOCKER CE"></a>7、安装DOCKER CE</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>



<h3 id="8、启动docker"><a href="#8、启动docker" class="headerlink" title="8、启动docker"></a>8、启动docker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<h3 id="9、重启docker"><a href="#9、重启docker" class="headerlink" title="9、重启docker"></a>9、重启docker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h3 id="10、测试"><a href="#10、测试" class="headerlink" title="10、测试"></a>10、测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>出现以下说明安装成功！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/07.png" alt="img"></p>
<h3 id="11、卸载"><a href="#11、卸载" class="headerlink" title="11、卸载"></a>11、卸载</h3><p><strong>停止docker服务</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>



<p><strong>卸载 Docker 引擎、CLI 和容器包：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>



<p><strong>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有映像、容器和卷：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>



<h3 id="12、阿里云镜像加速"><a href="#12、阿里云镜像加速" class="headerlink" title="12、阿里云镜像加速"></a>12、阿里云镜像加速</h3><p><strong>（1）来到阿里云的容器镜像服务</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/08.png" alt="08"></p>
<p><strong>（2）根据操作文档进行操作</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/09.png" alt="09"></p>
<p><strong>（3）代码</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内容到daemon.json文件</span></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://w0ycug45.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="为什么-Docker-会比-VM-虚拟机快"><a href="#为什么-Docker-会比-VM-虚拟机快" class="headerlink" title="为什么 Docker 会比 VM 虚拟机快"></a>为什么 Docker 会比 VM 虚拟机快</h2><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>（1）docker 有着比虚拟机更少的抽象层</strong></p>
<p><strong>由于 docker 不需要 Hypervisor（虚拟机）实现硬件资源虚拟化,运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 docker 将会在效率上有明显优势。</strong></p>
<p><strong>（2）docker 利用的是宿主机的内核,而不需要加载操作系统OS内核</strong></p>
<p><strong>当新建一个容器时，docker 不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载 OS,返回新建过程是分钟级别的。而 docker 由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个 docker 容器只需要几秒钟。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/10.png" alt="10"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/11.png" alt="11"></p>
<h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><h3 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h3><h4 id="（1）启动docker"><a href="#（1）启动docker" class="headerlink" title="（1）启动docker"></a>（1）启动docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<h4 id="（2）停止docker"><a href="#（2）停止docker" class="headerlink" title="（2）停止docker"></a>（2）停止docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>



<h4 id="（3）重启docker"><a href="#（3）重启docker" class="headerlink" title="（3）重启docker"></a>（3）重启docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h4 id="（4）查看docker-状态"><a href="#（4）查看docker-状态" class="headerlink" title="（4）查看docker 状态"></a>（4）查看docker 状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>



<h4 id="（5）开机启动"><a href="#（5）开机启动" class="headerlink" title="（5）开机启动"></a>（5）开机启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>



<h4 id="（6）查看docker-概要信息"><a href="#（6）查看docker-概要信息" class="headerlink" title="（6）查看docker 概要信息"></a>（6）查看docker 概要信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>



<h4 id="（7）查看docker-总体帮助文档"><a href="#（7）查看docker-总体帮助文档" class="headerlink" title="（7）查看docker 总体帮助文档"></a>（7）查看docker 总体帮助文档</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure>



<h4 id="（8）查看docker-命令帮助文档"><a href="#（8）查看docker-命令帮助文档" class="headerlink" title="（8）查看docker 命令帮助文档"></a>（8）查看docker 命令帮助文档</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure>



<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="（1）列出本地主机上的镜像"><a href="#（1）列出本地主机上的镜像" class="headerlink" title="（1）列出本地主机上的镜像"></a>（1）列出本地主机上的镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<p><strong>OPTIONS 说明：</strong></p>
<ul>
<li><strong>-a：列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</strong></li>
<li><strong>–digests：显示镜像的摘要信息；</strong></li>
<li><strong>-f：显示满足条件的镜像；</strong></li>
<li><strong>–format：指定返回值的模板文件；</strong></li>
<li><strong>–no-trunc：显示完整的镜像信息；</strong></li>
<li><strong>-q：只显示镜像ID。</strong></li>
</ul>
<h4 id="（2）从Docker-Hub-查找镜像"><a href="#（2）从Docker-Hub-查找镜像" class="headerlink" title="（2）从Docker Hub 查找镜像"></a>（2）从Docker Hub 查找镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure>



<p><strong>OPTIONS 说明：</strong></p>
<ul>
<li><p><strong>–automated :只列出 automated build类型的镜像；</strong></p>
</li>
<li><p><strong>–no-trunc :显示完整的镜像描述；</strong></p>
</li>
<li><p><strong>-f &lt;过滤条件&gt;:列出收藏数不小于指定值的镜像。</strong></p>
</li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>NAME：镜像仓库源的名称</strong></li>
<li><strong>DESCRIPTION：镜像的描述</strong></li>
<li><strong>OFFICIAL：是否 docker 官方发布</strong></li>
<li><strong>stars：类似 Github 里面的 star，表示点赞、喜欢的意思。</strong></li>
<li><strong>AUTOMATED：自动构建。</strong></li>
</ul>
<h4 id="（3）从镜像仓库中拉取或者更新指定镜像"><a href="#（3）从镜像仓库中拉取或者更新指定镜像" class="headerlink" title="（3）从镜像仓库中拉取或者更新指定镜像"></a>（3）从镜像仓库中拉取或者更新指定镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>

<p><strong>OPTIONS 说明：</strong></p>
<ul>
<li><strong>-a：拉取所有 tagged 镜像</strong></li>
<li><strong>–disable-content-trust：忽略镜像的校验,默认开启</strong></li>
</ul>
<h4 id="（4）查看镜像-x2F-容器-x2F-数据卷所占的空间"><a href="#（4）查看镜像-x2F-容器-x2F-数据卷所占的空间" class="headerlink" title="（4）查看镜像&#x2F;容器&#x2F;数据卷所占的空间"></a>（4）查看镜像&#x2F;容器&#x2F;数据卷所占的空间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>



<h4 id="（5）-删除本地一个或多个镜像"><a href="#（5）-删除本地一个或多个镜像" class="headerlink" title="（5） 删除本地一个或多个镜像"></a>（5） 删除本地一个或多个镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>



<p><strong>OPTIONS说明：</strong></p>
<p><strong>-f：强制删除；</strong></p>
<p><strong>–no-prune：不移除该镜像的过程镜像，默认移除；</strong></p>
<h3 id="虚拟镜像"><a href="#虚拟镜像" class="headerlink" title="虚拟镜像"></a>虚拟镜像</h3><h4 id="虚拟镜像是什么"><a href="#虚拟镜像是什么" class="headerlink" title="虚拟镜像是什么"></a>虚拟镜像是什么</h4><blockquote>
<p><strong>仓库名、标签都是<none>的镜像，俗称虚拟镜像dangling image</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/12.png" alt="12"></p>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><blockquote>
<p><strong>注意：有镜像才能创建容器，这是根本前提。</strong></p>
</blockquote>
<h4 id="（1）创建一个新的容器并运行一个命令"><a href="#（1）创建一个新的容器并运行一个命令" class="headerlink" title="（1）创建一个新的容器并运行一个命令"></a>（1）创建一个新的容器并运行一个命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>



<p><strong>OPTIONS 说明：</strong></p>
<ul>
<li><strong>-a stdin：指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</strong></li>
<li><strong>-d：后台运行容器，并返回容器ID；</strong></li>
<li><strong>-i：以交互模式运行容器，通常与 -t 同时使用；</strong></li>
<li><strong>-P：随机端口映射，容器内部端口随机映射到主机的端口</strong></li>
<li><strong>-p：指定端口映射，格式为：主机(宿主)端口:容器端口</strong></li>
<li><strong>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</strong></li>
<li><strong>–name&#x3D;”nginx-lb”：为容器指定一个名称；</strong></li>
<li><strong>–dns 8.8.8.8：指定容器使用的DNS服务器，默认和宿主一致；</strong></li>
<li><strong>–dns-search example.com：指定容器DNS搜索域名，默认和宿主一致；</strong></li>
<li><strong>-h “mars”：指定容器的hostname；</strong></li>
<li><strong>-e username&#x3D;”ritchie”: 设置环境变量；</strong></li>
<li><strong>–env-file&#x3D;[]：从指定文件读入环境变量；</strong></li>
<li><strong>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”：绑定容器到指定CPU运行；</strong></li>
<li><strong>-m：设置容器使用内存最大值；</strong></li>
<li><strong>–net&#x3D;”bridge”：指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</strong></li>
<li><strong>–link&#x3D;[]：添加链接到另一个容器；</strong></li>
<li><strong>–expose&#x3D;[]：开放一个端口或一组端口；</strong></li>
<li><strong>–volume , -v：绑定一个卷</strong></li>
</ul>
<h4 id="（2）列出当前所有正在运行的容器"><a href="#（2）列出当前所有正在运行的容器" class="headerlink" title="（2）列出当前所有正在运行的容器"></a>（2）列出当前所有正在运行的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>



<p><strong>OPTIONS说明：</strong></p>
<ul>
<li><strong>-a：显示所有的容器，包括未运行的。</strong></li>
<li><strong>-f：根据条件过滤显示的内容。</strong></li>
<li><strong>–format：指定返回值的模板文件。</strong></li>
<li><strong>-l：显示最近创建的容器。</strong></li>
<li><strong>-n：列出最近创建的n个容器。</strong></li>
<li><strong>–no-trunc：不截断输出。</strong></li>
<li><strong>-q：静默模式，只显示容器编号。</strong></li>
<li><strong>-s：显示总的文件大小。</strong></li>
</ul>
<h4 id="（3）退出容器"><a href="#（3）退出容器" class="headerlink" title="（3）退出容器"></a>（3）退出容器</h4><p>**方式一：exit	**</p>
<p><strong>run 进去容器，exit 退出，容器停止</strong>。</p>
<p>**方式二：ctrl+p+q	**</p>
<p><strong>run 进去容器，ctrl+p+q 退出，容器不停止。</strong></p>
<h4 id="（4）启动已停止运行的容器"><a href="#（4）启动已停止运行的容器" class="headerlink" title="（4）启动已停止运行的容器"></a>（4）启动已停止运行的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID/容器名</span><br></pre></td></tr></table></figure>



<h4 id="（5）重启容器"><a href="#（5）重启容器" class="headerlink" title="（5）重启容器"></a>（5）重启容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID/容器名</span><br></pre></td></tr></table></figure>



<h4 id="（6）停止容器"><a href="#（6）停止容器" class="headerlink" title="（6）停止容器"></a>（6）停止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID/容器名</span><br></pre></td></tr></table></figure>



<h4 id="（7）强制停止容器"><a href="#（7）强制停止容器" class="headerlink" title="（7）强制停止容器"></a>（7）强制停止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器ID/容器名</span><br></pre></td></tr></table></figure>



<h4 id="（8）删除已停止的容器"><a href="#（8）删除已停止的容器" class="headerlink" title="（8）删除已停止的容器"></a>（8）删除已停止的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="（9）一次性删除多个容器实例"><a href="#（9）一次性删除多个容器实例" class="headerlink" title="（9）一次性删除多个容器实例"></a>（9）<strong>一次性删除多个容器实例</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q) </span><br><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure>



<h4 id="（10）启动守护式容器（后台服务器）"><a href="#（10）启动守护式容器（后台服务器）" class="headerlink" title="（10）启动守护式容器（后台服务器）"></a>（10）启动守护式容器（后台服务器）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run d 容器名</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例：使用镜像 centos:latest 以后台模式启动一个容器</strong></p>
<p><strong><code>docker run -d centos</code></strong></p>
<p><strong>问题：然后docker ps -a 进行查看, 会发现容器已经退出</strong>。</p>
<p><strong>很重要的要说明的一点：Docker 容器后台运行,就必须有一个前台进程</strong>，容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。**</p>
<hr>
<p><strong>这个是 docker 的机制问题,比如你的 web 容器,我们以 nginx 为例，正常情况下，我们配置启动服务只需要启动响应的 service 即可。例如 <code>service nginx start</code></strong></p>
<p><strong>但是,这样做，nginx 为后台进程模式运行,就导致 docker 前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。</strong></p>
<p><strong>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~</strong></p>
</blockquote>
<h4 id="（11）查看容器日志"><a href="#（11）查看容器日志" class="headerlink" title="（11）查看容器日志"></a>（11）查看容器日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="（12）查看容器内运行的进程"><a href="#（12）查看容器内运行的进程" class="headerlink" title="（12）查看容器内运行的进程"></a>（12）查看容器内运行的进程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="（13）查看容器内部细节"><a href="#（13）查看容器内部细节" class="headerlink" title="（13）查看容器内部细节"></a>（13）查看容器内部细节</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="（14）进入正在运行的容器并以命令行交互"><a href="#（14）进入正在运行的容器并以命令行交互" class="headerlink" title="（14）进入正在运行的容器并以命令行交互"></a>（14）进入正在运行的容器并以命令行交互</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>或</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID  </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>推荐使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。</strong></p>
</blockquote>
<p><strong>两个命令的区别</strong></p>
<blockquote>
<ul>
<li><strong>exec 是在容器中打开新的终端，并且可以启动新的进程，用 exit 退出，不会导致容器的停止。</strong></li>
<li><strong>attach 直接进入容器启动命令的终端，不会启动新的进程，用 exit 退出，会导致容器的停止。</strong></li>
</ul>
</blockquote>
<h4 id="（15）从容器内拷贝文件到主机上"><a href="#（15）从容器内拷贝文件到主机上" class="headerlink" title="（15）从容器内拷贝文件到主机上"></a>（15）从容器内拷贝文件到主机上</h4><blockquote>
<p><strong>容器→主机</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 6610152993fc:/demo.txt /local/huang.txt</span><br></pre></td></tr></table></figure>



<h4 id="（16）导入和导出容器"><a href="#（16）导入和导出容器" class="headerlink" title="（16）导入和导出容器"></a>（16）导入和导出容器</h4><blockquote>
<p><strong>export 导出容器的内容留作一个 tar 归档文件[对应 import 命令]</strong></p>
<p><strong>import 从 tar 包中的内容创建一个新的文件系统再导入为镜像[对应 export]</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker export 容器ID &gt; 文件名.tar</span><br><span class="line">cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出容器</span></span><br><span class="line">docker export 6610152993fc &gt; huang.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 6610152993fc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已停止的容器</span></span><br><span class="line">docker rm 6610152993fc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入容器</span></span><br><span class="line">cat huang.tar | docker import - huang/ubuntu:1.0</span><br></pre></td></tr></table></figure>



<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><center><strong>图片正下方还有命令</strong></center>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/13.png" alt="13"></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>attach</strong></td>
<td align="center"><strong>Attach to a running container</strong></td>
<td align="center"><strong>当前 shell 下 attach 连接指定运行镜像</strong></td>
</tr>
<tr>
<td align="center"><strong>build</strong></td>
<td align="center"><strong>Build an image from a Dockerfile</strong></td>
<td align="center"><strong>通过 Dockerfile 定制镜像</strong></td>
</tr>
<tr>
<td align="center"><strong>commit</strong></td>
<td align="center"><strong>Create a new image from a container changes</strong></td>
<td align="center"><strong>提交当前容器为新的镜像</strong></td>
</tr>
<tr>
<td align="center"><strong>cp</strong></td>
<td align="center"><strong>Copy files&#x2F;folders from the containers filesystem to the host path</strong></td>
<td align="center"><strong>从容器中拷贝指定文件或者目录到宿主机中</strong></td>
</tr>
<tr>
<td align="center"><strong>create</strong></td>
<td align="center"><strong>Create a new container</strong></td>
<td align="center"><strong>创建一个新的容器，同 run，但不启动容器</strong></td>
</tr>
<tr>
<td align="center"><strong>diff</strong></td>
<td align="center"><strong>Inspect changes on a container’s filesystem</strong></td>
<td align="center"><strong>查看 docker 容器变化</strong></td>
</tr>
<tr>
<td align="center"><strong>events</strong></td>
<td align="center"><strong>Get real time events from the server</strong></td>
<td align="center"><strong>从 docker 服务获取容器实时事件</strong></td>
</tr>
<tr>
<td align="center"><strong>exec</strong></td>
<td align="center"><strong>Run a command in an existing container</strong></td>
<td align="center"><strong>在已存在的容器上运行命令</strong></td>
</tr>
<tr>
<td align="center"><strong>export</strong></td>
<td align="center"><strong>Stream the contents of a container as a tar archive</strong></td>
<td align="center"><strong>导出容器的内容流作为一个 tar 归档文件[对应 import ]</strong></td>
</tr>
<tr>
<td align="center"><strong>history</strong></td>
<td align="center"><strong>Show the history of an image</strong></td>
<td align="center"><strong>展示一个镜像形成历史</strong></td>
</tr>
<tr>
<td align="center"><strong>images</strong></td>
<td align="center"><strong>List images</strong></td>
<td align="center"><strong>列出系统当前镜像</strong></td>
</tr>
<tr>
<td align="center"><strong>import</strong></td>
<td align="center"><strong>Create a new filesystem image from the contents of a tarball</strong></td>
<td align="center"><strong>从tar包中的内容创建一个新的文件系统映像[对应export]</strong></td>
</tr>
<tr>
<td align="center"><strong>info</strong></td>
<td align="center"><strong>Display system-wide information</strong></td>
<td align="center"><strong>显示系统相关信息</strong></td>
</tr>
<tr>
<td align="center"><strong>inspect</strong></td>
<td align="center"><strong>Return low-level information on a container</strong></td>
<td align="center"><strong>查看容器详细信息</strong></td>
</tr>
<tr>
<td align="center"><strong>kill</strong></td>
<td align="center"><strong>Kill a running container</strong></td>
<td align="center"><strong>kill 指定 docker 容器</strong></td>
</tr>
<tr>
<td align="center"><strong>load</strong></td>
<td align="center"><strong>Load an image from a tar archive</strong></td>
<td align="center"><strong>从一个 tar 包中加载一个镜像[对应 save]</strong></td>
</tr>
<tr>
<td align="center"><strong>login</strong></td>
<td align="center"><strong>Register or Login to the docker registry server</strong></td>
<td align="center"><strong>注册或者登陆一个 docker 源服务器</strong></td>
</tr>
<tr>
<td align="center"><strong>logout</strong></td>
<td align="center"><strong>Log out from a Docker registry server</strong></td>
<td align="center"><strong>从当前 Docker registry 退出</strong></td>
</tr>
<tr>
<td align="center"><strong>logs</strong></td>
<td align="center"><strong>Fetch the logs of a container</strong></td>
<td align="center"><strong>输出当前容器日志信息</strong></td>
</tr>
<tr>
<td align="center"><strong>port</strong></td>
<td align="center"><strong>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</strong></td>
<td align="center"><strong>查看映射端口对应的容器内部源端口</strong></td>
</tr>
<tr>
<td align="center"><strong>pause</strong></td>
<td align="center"><strong>Pause all processes within a container</strong></td>
<td align="center"><strong>暂停容器</strong></td>
</tr>
<tr>
<td align="center"><strong>ps</strong></td>
<td align="center"><strong>List containers</strong></td>
<td align="center"><strong>列出容器列表</strong></td>
</tr>
<tr>
<td align="center"><strong>pull</strong></td>
<td align="center"><strong>Pull an image or a repository from the docker registry server</strong></td>
<td align="center"><strong>从docker镜像源服务器拉取指定镜像或者库镜像</strong></td>
</tr>
<tr>
<td align="center"><strong>push</strong></td>
<td align="center"><strong>Push an image or a repository to the docker registry server</strong></td>
<td align="center"><strong>推送指定镜像或者库镜像至docker源服务器</strong></td>
</tr>
<tr>
<td align="center"><strong>restart</strong></td>
<td align="center"><strong>Restart a running container</strong></td>
<td align="center"><strong>重启运行的容器</strong></td>
</tr>
<tr>
<td align="center"><strong>rm</strong></td>
<td align="center"><strong>Remove one or more containers</strong></td>
<td align="center"><strong>移除一个或者多个容器</strong></td>
</tr>
<tr>
<td align="center"><strong>rmi</strong></td>
<td align="center"><strong>Remove one or more images</strong></td>
<td align="center"><strong>移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</strong></td>
</tr>
<tr>
<td align="center"><strong>run</strong></td>
<td align="center"><strong>Run a command in a new container</strong></td>
<td align="center"><strong>创建一个新的容器并运行一个命令</strong></td>
</tr>
<tr>
<td align="center"><strong>save</strong></td>
<td align="center"><strong>Save an image to a tar archive</strong></td>
<td align="center"><strong>保存一个镜像为一个 tar 包[对应 load]</strong></td>
</tr>
<tr>
<td align="center"><strong>search</strong></td>
<td align="center"><strong>Search for an image on the Docker Hub</strong></td>
<td align="center"><strong>在 docker hub 中搜索镜像</strong></td>
</tr>
<tr>
<td align="center"><strong>start</strong></td>
<td align="center"><strong>Start a stopped containers</strong></td>
<td align="center"><strong>启动容器</strong></td>
</tr>
<tr>
<td align="center"><strong>stop</strong></td>
<td align="center"><strong>Stop a running containers</strong></td>
<td align="center"><strong>停止容器</strong></td>
</tr>
<tr>
<td align="center"><strong>tag</strong></td>
<td align="center"><strong>Tag an image into a repository</strong></td>
<td align="center"><strong>给源中镜像打标签</strong></td>
</tr>
<tr>
<td align="center"><strong>top</strong></td>
<td align="center"><strong>Lookup the running processes of a container</strong></td>
<td align="center"><strong>查看容器中运行的进程信息</strong></td>
</tr>
<tr>
<td align="center"><strong>unpause</strong></td>
<td align="center"><strong>Unpause a paused container</strong></td>
<td align="center"><strong>取消暂停容器</strong></td>
</tr>
<tr>
<td align="center"><strong>version</strong></td>
<td align="center"><strong>Show the docker version information</strong></td>
<td align="center"><strong>查看 docker 版本号</strong></td>
</tr>
<tr>
<td align="center"><strong>wait</strong></td>
<td align="center"><strong>Block until a container stops, then print its exit code</strong></td>
<td align="center"><strong>截取容器停止时的退出状态值</strong></td>
</tr>
</tbody></table>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><blockquote>
<p><strong>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是 image 镜像文件。</strong></p>
<p><strong>只有通过这个镜像文件才能生成 Docker 容器实例（类似 Java 中 new 出来一个对象）。</strong></p>
</blockquote>
<h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><blockquote>
<p><strong>以我们的 pull 为例，在下载的过程中我们可以看到 docker 的镜像好像是在一层一层的在下载。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/14.png" alt="14"></p>
<h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><blockquote>
<p><strong>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</strong></p>
</blockquote>
<h3 id="Docker-镜像加载原理"><a href="#Docker-镜像加载原理" class="headerlink" title="Docker 镜像加载原理"></a>Docker 镜像加载原理</h3><blockquote>
<p><strong>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</strong></p>
<p><strong>bootfs（boot file system）主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是引导文件系统 bootfs。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</strong></p>
<p><strong>rootfs（root file system），在 bootfs 之上。包含的就是典型 Linux 系统中的 &#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</strong> </p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/15.png" alt="15"></p>
<blockquote>
<p><strong>平时我们安装进虚拟机的 CentOS 都是好几个G，为什么 docker 这里才200M？</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/16.png" alt="16"></p>
<blockquote>
<p><strong>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的 Linux 发行版，bootfs 基本是一致的，rootfs 会有差别, 因此不同的发行版可以公用 bootfs。</strong></p>
</blockquote>
<h3 id="为什么-Docker-镜像要采用这种分层结构呢"><a href="#为什么-Docker-镜像要采用这种分层结构呢" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢"></a>为什么 Docker 镜像要采用这种分层结构呢</h3><blockquote>
<p><strong>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</strong></p>
<p><strong>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</strong></p>
<p><strong>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</strong></p>
</blockquote>
<h3 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h3><blockquote>
<p><strong>Docker 镜像层都是只读的，容器层是可写的</strong></p>
<p><strong>当容器启动时，一个新的可写层被加载到镜像的顶部。</strong></p>
<p><strong>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</strong></p>
</blockquote>
<h3 id="Docker-镜像-commit-操作案例"><a href="#Docker-镜像-commit-操作案例" class="headerlink" title="Docker 镜像 commit 操作案例"></a>Docker 镜像 commit 操作案例</h3><p><strong>（1）从 Docker Hub 上下载 ubuntu 镜像到本地并成功运行</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器</span></span><br><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure>



<p><strong>（2）安装 vim 命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先更新我们的包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后安装我们需要的 vim 命令</span></span><br><span class="line">apt-get -y install vim</span><br></pre></td></tr></table></figure>



<p><strong>（3）安装完成后，commit 我们自己的新镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;vim cmd add ok&quot; -a=&quot;huang&quot; 9b678b384d31 huang/myubuntu:1.0</span><br></pre></td></tr></table></figure>



<p><strong>（4）启动我们的新镜像和原来的对比</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/17.png" alt="17"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker run -it ubuntu /bin/bash</span><br><span class="line">root@6de30c5f70ac:/# vim a.txt</span><br><span class="line">bash: vim: command not found</span><br><span class="line">root@6de30c5f70ac:/# exit     </span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker run -it 54ac0505e68e /bin/bash</span><br><span class="line">root@26d4c7e82170:/# vim a.txt</span><br><span class="line">root@26d4c7e82170:/# </span><br></pre></td></tr></table></figure>



<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><blockquote>
<p><strong>Docker 中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似 Java 继承于一个 Base 基础类，自己再按需扩展。</strong></p>
<p><strong>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/18.png" alt="18"></p>
<h2 id="本地镜像发布到阿里云"><a href="#本地镜像发布到阿里云" class="headerlink" title="本地镜像发布到阿里云"></a>本地镜像发布到阿里云</h2><h3 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/19.png" alt="19"></p>
<h4 id="（1）创建仓库镜像"><a href="#（1）创建仓库镜像" class="headerlink" title="（1）创建仓库镜像"></a>（1）创建仓库镜像</h4><center><strong>进入到阿里云容器镜像服务页面</strong></center>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/20.png" alt="20"></p>
<center><strong>创建个人版实例</strong></center>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/21.png" alt="21"></p>
<center><strong>创建命名空间</strong></center>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/22.png" alt="22"></p>
<center><strong>创建仓库</strong></center>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/23.png" alt="23"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/24.png" alt="24"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/25.png" alt="25"></p>
<h4 id="（2）将本地镜像推送到阿里云"><a href="#（2）将本地镜像推送到阿里云" class="headerlink" title="（2）将本地镜像推送到阿里云"></a>（2）将本地镜像推送到阿里云</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 登录阿里云Docker Registry</span></span><br><span class="line">docker login --username=枯木逢春ioi registry.cn-shenzhen.aliyuncs.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 将镜像推送到Registry</span></span><br><span class="line">docker tag 54ac0505e68e registry.cn-shenzhen.aliyuncs.com/minami/myubuntu:1.0</span><br><span class="line">docker push registry.cn-shenzhen.aliyuncs.com/minami/myubuntu:1.0</span><br></pre></td></tr></table></figure>



<h3 id="从阿里云镜像仓库拉取镜像"><a href="#从阿里云镜像仓库拉取镜像" class="headerlink" title="从阿里云镜像仓库拉取镜像"></a>从阿里云镜像仓库拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-shenzhen.aliyuncs.com/minami/myubuntu:1.0</span><br></pre></td></tr></table></figure>



<h2 id="本地镜像发布到私有库"><a href="#本地镜像发布到私有库" class="headerlink" title="本地镜像发布到私有库"></a>本地镜像发布到私有库</h2><blockquote>
<p><strong>官方 Docker Hub地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/%EF%BC%8C%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E8%AE%BF%E9%97%AE%E5%A4%AA%E6%85%A2%E4%BA%86%E4%B8%94%E5%87%86%E5%A4%87%E8%A2%AB%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%96%E4%BB%A3%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%8C%E4%B8%8D%E5%A4%AA%E4%B8%BB%E6%B5%81%E3%80%82">https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</a></strong></p>
<p><strong>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</strong></p>
<p><strong>Docker Registry 是官方提供的工具，可以用于构建私有镜像仓库</strong></p>
</blockquote>
<h3 id="将本地镜像推送到私有库"><a href="#将本地镜像推送到私有库" class="headerlink" title="将本地镜像推送到私有库"></a>将本地镜像推送到私有库</h3><h4 id="1、下载镜像-Docker-Registry"><a href="#1、下载镜像-Docker-Registry" class="headerlink" title="1、下载镜像 Docker Registry"></a>1、下载镜像 Docker Registry</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>



<h4 id="2、运行私有库-Registry，相当于本地有个私有-Docker-hub"><a href="#2、运行私有库-Registry，相当于本地有个私有-Docker-hub" class="headerlink" title="2、运行私有库 Registry，相当于本地有个私有 Docker hub"></a>2、运行私有库 Registry，相当于本地有个私有 Docker hub</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /huang/myregistry/:/tmp/registry --privileged=true registry</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>默认情况，仓库被创建在容器的<code>/var/lib/registry</code>目录下，建议自行用容器卷映射，方便于宿主机联调。</strong></p>
</blockquote>
<h4 id="3、案例演示创建一个新镜像，ubuntu-安装-ifconfig-命令"><a href="#3、案例演示创建一个新镜像，ubuntu-安装-ifconfig-命令" class="headerlink" title="3、案例演示创建一个新镜像，ubuntu 安装 ifconfig 命令"></a>3、案例演示创建一个新镜像，ubuntu 安装 ifconfig 命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先更新我们的包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后安装我们需要的 vim 命令</span></span><br><span class="line">apt-get -y install net-tools</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装完成后，commit 我们自己的新镜像</span></span><br><span class="line">docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;huang&quot; 5a565940abde huangubuntu:2.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行刚刚 commit 的镜像</span></span><br><span class="line">docker run -it 5185f9b2130c /bin/bash</span><br></pre></td></tr></table></figure>



<h4 id="4、curl-验证私服库上有什么镜像"><a href="#4、curl-验证私服库上有什么镜像" class="headerlink" title="4、curl 验证私服库上有什么镜像"></a>4、curl 验证私服库上有什么镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://120.78.11.141:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：这里需要到阿里云安全组里开放 5000 端口。</strong></p>
</blockquote>
<h4 id="5、将新镜像-huangubuntu2-0-修改符合私服规范的-Tag"><a href="#5、将新镜像-huangubuntu2-0-修改符合私服规范的-Tag" class="headerlink" title="5、将新镜像 huangubuntu2.0 修改符合私服规范的 Tag"></a>5、将新镜像 huangubuntu2.0 修改符合私服规范的 Tag</h4><blockquote>
<p><strong>按照公式：<code>docker tag 镜像:Tag Host:Port/Repository:Tag</code></strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker tag huangubuntu:2.0 120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line"></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker images</span><br><span class="line">REPOSITORY                                          TAG       IMAGE ID       CREATED             SIZE</span><br><span class="line">120.78.11.141:5000/huangubuntu                      2.0       5185f9b2130c   11 minutes ago      109MB</span><br><span class="line">huangubuntu                                         2.0       5185f9b2130c   11 minutes ago      109MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/minami/myubuntu   1.0       54ac0505e68e   About an hour ago   176MB</span><br><span class="line">registry                                            latest    b8604a3fe854   5 months ago        26.2MB</span><br><span class="line">ubuntu                                              latest    ba6acccedd29   6 months ago        72.8MB</span><br></pre></td></tr></table></figure>



<h4 id="6、修改配置文件使之支持-http"><a href="#6、修改配置文件使之支持-http" class="headerlink" title="6、修改配置文件使之支持 http"></a>6、修改配置文件使之支持 http</h4><p><strong>vim命令新增如下红色内容：<code>vim /etc/docker/daemon.json</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecure-registries&quot;: [&quot;120.78.11.141:5000&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>添加后的完整文件内容如下：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://w0ycug45.mirror.aliyuncs.com&quot;]，</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;120.78.11.141:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>别无脑照着复制，registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。</strong><br><strong>2个配置中间有个逗号 ‘,’别漏了，这个配置是 json 格式的。</strong><br><strong>2个配置中间有个逗号 ‘,’别漏了，这个配置是 json 格式的。</strong><br><strong>2个配置中间有个逗号 ‘,’别漏了，这个配置是 json 格式的。</strong></p>
<p><strong>上述理由：docker 默认不允许 http 方式推送镜像，通过配置选项来取消这个限制。&#x3D;&#x3D;&#x3D;&#x3D;&gt; 修改完后如果不生效，建议重启docker</strong></p>
</blockquote>
<h4 id="7、push-推送到私服库"><a href="#7、push-推送到私服库" class="headerlink" title="7、push 推送到私服库"></a>7、push 推送到私服库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 Docker</span></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# systemctl restart docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行私有仓库</span></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker run -d -p 5000:5000  -v /huang/myregistry/:/tmp/registry --privileged=true registry</span><br><span class="line">2de0c3f7eab806a6b8faa91abcfa44d7ba8073d58664734e897506719187c125</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送</span></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker push 120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="8、curl-验证私服库上有什么镜像"><a href="#8、curl-验证私服库上有什么镜像" class="headerlink" title="8、curl 验证私服库上有什么镜像"></a>8、curl 验证私服库上有什么镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# curl -XGET http://120.78.11.141:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;huangubuntu&quot;]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9、pull-到本地并运行"><a href="#9、pull-到本地并运行" class="headerlink" title="9、pull 到本地并运行"></a>9、pull 到本地并运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker rmi -f 120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line">Untagged: 120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line">Untagged: 120.78.11.141:5000/huangubuntu@sha256:e8a2f670d94dfbbc97e1c1c2b9ba5d36b85e96e5b8818dc03af6c9fa8791cce6</span><br><span class="line"></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker pull 120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line">2.0: Pulling from huangubuntu</span><br><span class="line">7b1a6ab2e44d: Already exists </span><br><span class="line">a4efec4ddfa0: Already exists </span><br><span class="line">Digest: sha256:e8a2f670d94dfbbc97e1c1c2b9ba5d36b85e96e5b8818dc03af6c9fa8791cce6</span><br><span class="line">Status: Downloaded newer image for 120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line">120.78.11.141:5000/huangubuntu:2.0</span><br><span class="line"></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker images</span><br><span class="line">REPOSITORY                                          TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">120.78.11.141:5000/huangubuntu                      2.0       5185f9b2130c   39 minutes ago   109MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/minami/myubuntu   1.0       54ac0505e68e   2 hours ago      176MB</span><br><span class="line">registry                                            latest    b8604a3fe854   5 months ago     26.2MB</span><br><span class="line">ubuntu                                              latest    ba6acccedd29   6 months ago     72.8MB</span><br><span class="line"></span><br><span class="line">[root@iZwz9104i5lanril7l7pz3Z /]# docker run -it 5185f9b2130c /bin/bash</span><br><span class="line"></span><br><span class="line">root@edc01cd7addd:/# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>



<h2 id="Docker-容器数据卷"><a href="#Docker-容器数据卷" class="headerlink" title="Docker 容器数据卷"></a>Docker 容器数据卷</h2><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><blockquote>
<p><strong>容器卷记得加入：<code>privileged=true</code></strong></p>
<p><strong>原因：</strong></p>
<p><strong>Docker 挂载主机目录访问如果出现cannot open directory .: Permission denied</strong></p>
<p><strong>解决办法：在挂载目录后多加一个<code>--privileged=true</code>参数即可</strong></p>
<p><strong>如果是 CentOS7 安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container 内的 root 拥有真正的 root 权限，否则，container 内的 root 只是外部的一个普通用户权限。</strong></p>
</blockquote>
<h3 id="Docker-容器数据卷是什么"><a href="#Docker-容器数据卷是什么" class="headerlink" title="Docker 容器数据卷是什么"></a>Docker 容器数据卷是什么</h3><blockquote>
<p><strong>一句话：有点类似我们 Redis 里面的 RDB 和 AOF 文件。</strong></p>
<p><strong>将 Docker 容器内的数据保存进宿主机的磁盘中.</strong></p>
</blockquote>
<h3 id="运行一个带有容器卷存储功能的容器实例"><a href="#运行一个带有容器卷存储功能的容器实例" class="headerlink" title="运行一个带有容器卷存储功能的容器实例"></a>运行一个带有容器卷存储功能的容器实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v/宿主机的绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>



<h3 id="Docker-容器数据卷能干什么"><a href="#Docker-容器数据卷能干什么" class="headerlink" title="Docker 容器数据卷能干什么"></a>Docker 容器数据卷能干什么</h3><blockquote>
<p><strong>将运用与运行的环境打包镜像，run 后形成容器实例运行 ，但是我们对数据的要求希望是持久化的。</strong></p>
<p><strong>Docker 容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。</strong></p>
<p><strong>为了能保存数据在 docker 中我们使用卷。</strong></p>
<hr>
<p><strong>特点：</strong></p>
<p><strong>1：数据卷可在容器之间共享或重用数据。</strong></p>
<p><strong>2：卷中的更改可以直接实时生效，爽</strong>。</p>
<p><strong>3：数据卷中的更改不会包含在镜像的更新中。</strong></p>
<p><strong>4：数据卷的生命周期一直持续到没有容器使用它为止</strong>。</p>
</blockquote>
<h3 id="容器数据卷案例"><a href="#容器数据卷案例" class="headerlink" title="容器数据卷案例"></a>容器数据卷案例</h3><h4 id="1、宿主-VS-容器之间映射添加容器卷"><a href="#1、宿主-VS-容器之间映射添加容器卷" class="headerlink" title="1、宿主 VS 容器之间映射添加容器卷"></a>1、宿主 VS 容器之间映射添加容器卷</h4><h5 id="（1）直接命令添加"><a href="#（1）直接命令添加" class="headerlink" title="（1）直接命令添加"></a>（1）直接命令添加</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v/tmp/host_data:/tmp/docker_data --name=u1 ubuntu</span><br></pre></td></tr></table></figure>



<h5 id="（2）查看数据卷是否挂载成功"><a href="#（2）查看数据卷是否挂载成功" class="headerlink" title="（2）查看数据卷是否挂载成功"></a>（2）查看数据卷是否挂载成功</h5><blockquote>
<p><strong>命令：<code>docker inspect 容器ID</code></strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/26.png" alt="26"></p>
<h5 id="（3）容器和宿主机之间数据共享"><a href="#（3）容器和宿主机之间数据共享" class="headerlink" title="（3）容器和宿主机之间数据共享"></a>（3）容器和宿主机之间数据共享</h5><blockquote>
<p><strong>1、docker 修改，主机同步获得</strong> </p>
<p><strong>2、主机修改，docker 同步获得</strong></p>
<p><strong>3、docker 容器 stop，主机修改，docker 容器重启看数据是否同步。</strong></p>
</blockquote>
<h4 id="2、读写规则映射添加说明"><a href="#2、读写规则映射添加说明" class="headerlink" title="2、读写规则映射添加说明"></a>2、读写规则映射添加说明</h4><h5 id="读写（默认）"><a href="#读写（默认）" class="headerlink" title="读写（默认）"></a>读写（默认）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v/宿主机的绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>默认同上案例，默认就是 rw。</strong></p>
</blockquote>
<h5 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h5><blockquote>
<p><strong>容器实例内部被限制，只能读取（read only）不能写。</strong></p>
<p><strong>&#x2F;容器目录:ro 镜像名               就能完成功能，此时容器自己只能读取不能写</strong>  </p>
<p><strong>ro &#x3D; read only</strong></p>
<p><strong>此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v/宿主机的绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/27.png" alt="27"></p>
<h4 id="3、卷的继承和共享"><a href="#3、卷的继承和共享" class="headerlink" title="3、卷的继承和共享"></a>3、卷的继承和共享</h4><h5 id="（1）容器1完成和宿主机的映射"><a href="#（1）容器1完成和宿主机的映射" class="headerlink" title="（1）容器1完成和宿主机的映射"></a>（1）容器1完成和宿主机的映射</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/28.png" alt="28"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/29.png" alt="29"></p>
<h5 id="（2）容器2继承容器1的卷规则"><a href="#（2）容器2继承容器1的卷规则" class="headerlink" title="（2）容器2继承容器1的卷规则"></a>（2）容器2继承容器1的卷规则</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true --volumes-from 父类 --name u2 ubuntu</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/30.png" alt="30"></p>
<h2 id="Docker-常规安装简介"><a href="#Docker-常规安装简介" class="headerlink" title="Docker 常规安装简介"></a>Docker 常规安装简介</h2><h3 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h3><h4 id="（1）搜索镜像"><a href="#（1）搜索镜像" class="headerlink" title="（1）搜索镜像"></a><strong>（1）搜索镜像</strong></h4><h4 id="（2）拉取镜像"><a href="#（2）拉取镜像" class="headerlink" title="（2）拉取镜像"></a><strong>（2）拉取镜像</strong></h4><h4 id="（3）查看镜像"><a href="#（3）查看镜像" class="headerlink" title="（3）查看镜像"></a><strong>（3）查看镜像</strong></h4><h4 id="（4）启动镜像（服务端口映射）"><a href="#（4）启动镜像（服务端口映射）" class="headerlink" title="（4）启动镜像（服务端口映射）"></a>（4）启动镜像（服务端口映射）</h4><h4 id="（5）停止容器"><a href="#（5）停止容器" class="headerlink" title="（5）停止容器"></a><strong>（5）停止容器</strong></h4><h4 id="（6）移除容器"><a href="#（6）移除容器" class="headerlink" title="（6）移除容器"></a><strong>（6）移除容器</strong></h4><h3 id="Tomcat-安装"><a href="#Tomcat-安装" class="headerlink" title="Tomcat 安装"></a>Tomcat 安装</h3><h4 id="（1）Docker-hub-上面查找-Tomcat-镜像"><a href="#（1）Docker-hub-上面查找-Tomcat-镜像" class="headerlink" title="（1）Docker hub 上面查找 Tomcat 镜像"></a>（1）Docker hub 上面查找 Tomcat 镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure>



<h4 id="（2）从-Docker-hub-上拉取-Tomcat-镜像到本地"><a href="#（2）从-Docker-hub-上拉取-Tomcat-镜像到本地" class="headerlink" title="（2）从 Docker hub 上拉取 Tomcat 镜像到本地"></a>（2）从 Docker hub 上拉取 Tomcat 镜像到本地</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>



<h4 id="（3）docker-images-查看是否有拉取到-Tomcat"><a href="#（3）docker-images-查看是否有拉取到-Tomcat" class="headerlink" title="（3）docker images 查看是否有拉取到 Tomcat"></a>（3）docker images 查看是否有拉取到 Tomcat</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>



<h4 id="（4）使用-Tomcat-镜像创建容器实例（也叫运行镜像）"><a href="#（4）使用-Tomcat-镜像创建容器实例（也叫运行镜像）" class="headerlink" title="（4）使用 Tomcat 镜像创建容器实例（也叫运行镜像）"></a>（4）使用 Tomcat 镜像创建容器实例（也叫运行镜像）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name t1 tomcat</span><br></pre></td></tr></table></figure>

<p><strong>解决新版 Tomcat 问题：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到容器内部</span></span><br><span class="line">docker exec -it 2ae389b9976a /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/31.png" alt="31"></p>
<h4 id="（5）访问-Tomcat-首页"><a href="#（5）访问-Tomcat-首页" class="headerlink" title="（5）访问 Tomcat 首页"></a>（5）访问 Tomcat 首页</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/32.png" alt="32"></p>
<h4 id="（6）免修改版说明"><a href="#（6）免修改版说明" class="headerlink" title="（6）免修改版说明"></a>（6）免修改版说明</h4><blockquote>
<p><strong>只需要下载低版本的 Tomcat 即可。</strong></p>
</blockquote>
<h3 id="Mysql-安装"><a href="#Mysql-安装" class="headerlink" title="Mysql 安装"></a>Mysql 安装</h3><h4 id="（1）Docker-hub-上面查找-MySQL-镜像"><a href="#（1）Docker-hub-上面查找-MySQL-镜像" class="headerlink" title="（1）Docker hub 上面查找 MySQL 镜像"></a>（1）Docker hub 上面查找 MySQL 镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>



<h4 id="（2）从-Docker-hub-上（阿里云加速器）拉取-MySQL-镜像到本地标签为5-7"><a href="#（2）从-Docker-hub-上（阿里云加速器）拉取-MySQL-镜像到本地标签为5-7" class="headerlink" title="（2）从 Docker hub 上（阿里云加速器）拉取 MySQL 镜像到本地标签为5.7"></a>（2）从 Docker hub 上（阿里云加速器）拉取 MySQL 镜像到本地标签为5.7</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>



<h4 id="（3）使用-MySQL5-7-镜像创建容器（也叫运行镜像）"><a href="#（3）使用-MySQL5-7-镜像创建容器（也叫运行镜像）" class="headerlink" title="（3）使用 MySQL5.7 镜像创建容器（也叫运行镜像）"></a>（3）使用 MySQL5.7 镜像创建容器（也叫运行镜像）</h4><h5 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 MySQL 容器</span></span><br><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检测是否创建成功</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到容器里面</span></span><br><span class="line">docker exec -it 92f2ee78e06f /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 MySQL</span></span><br><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题1： Docker 上默认字符集编码隐患</strong></p>
<p><strong>docker里面的mysql容器实例查看，内容如下：</strong></p>
<p><strong>mysql&gt;  SHOW VARIABLES LIKE ‘character%’;</strong><br><strong>+————————–+—————————-+</strong><br><strong>| Variable_name            | Value                      |</strong><br><strong>+————————–+—————————-+</strong><br><strong>| character_set_client     | latin1                     |</strong><br><strong>| character_set_connection | latin1                     |</strong><br><strong>| character_set_database   | latin1                     |</strong><br><strong>| character_set_filesystem | binary                     |</strong><br><strong>| character_set_results    | latin1                     |</strong><br><strong>| character_set_server     | latin1                     |</strong><br><strong>| character_set_system     | utf8                       |</strong><br><strong>| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql&#x2F;charsets&#x2F; |</strong><br><strong>+————————–+—————————-+</strong><br><strong>8 rows in set (0.00 sec)</strong></p>
<p><strong>问题2：删除容器后，里面的 MySQL 数据怎么办？容器实例一删除，你还有什么？删容器到跑路。</strong></p>
</blockquote>
<h5 id="实战版"><a href="#实战版" class="headerlink" title="实战版"></a>实战版</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增 MySQL 容器实例</span></span><br><span class="line">docker run -d -p 3306:3306 --privileged=true -v /huang/mysql/log:/var/log/mysql -v /huang/mysql/data:/var/lib/mysql -v /huang/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456  --name mysql mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建 my.cnf 通过容器卷同步给 MySQL 实例</span></span><br><span class="line">cd /huang/mysql/conf/</span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否添加成功</span></span><br><span class="line">cat my.cnf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 MySQL 实例</span></span><br><span class="line">docker restart mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新进入容器</span></span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 MySQL</span></span><br><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看字符集编码</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW VARIABLES LIKE <span class="string">&#x27;character%&#x27;</span>;</span></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote>
<p><strong>前的DB  无效</strong></p>
<p><strong>修改字符集操作+重启mysql容器实例</strong></p>
<p><strong>之后的DB  有效，需要新建</strong></p>
<p><strong>结论：docker 安装完 MySQL 并 run 出容器后，建议请先修改完字符集编码后再新建 mysql 库-表-插数据</strong></p>
</blockquote>
<h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><h4 id="（1）从-Docker-hub（阿里云加速器）拉取-Redis-镜像到本地标签为6-2-6"><a href="#（1）从-Docker-hub（阿里云加速器）拉取-Redis-镜像到本地标签为6-2-6" class="headerlink" title="（1）从 Docker hub（阿里云加速器）拉取 Redis 镜像到本地标签为6.2.6"></a>（1）从 Docker hub（阿里云加速器）拉取 Redis 镜像到本地标签为6.2.6</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:6.2.6</span><br></pre></td></tr></table></figure>



<h4 id="（2）再-Centros-宿主机下新建目录-x2F-app-x2F-redis"><a href="#（2）再-Centros-宿主机下新建目录-x2F-app-x2F-redis" class="headerlink" title="（2）再 Centros 宿主机下新建目录&#x2F;app&#x2F;redis"></a>（2）再 Centros 宿主机下新建目录&#x2F;app&#x2F;redis</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /app/redis</span><br></pre></td></tr></table></figure>



<h4 id="（3）将一个-Redis-conf-文件模板拷贝进-x2F-app-x2F-redis目录下"><a href="#（3）将一个-Redis-conf-文件模板拷贝进-x2F-app-x2F-redis目录下" class="headerlink" title="（3）将一个 Redis.conf 文件模板拷贝进&#x2F;app&#x2F;redis目录下"></a>（3）将一个 Redis.conf 文件模板拷贝进&#x2F;app&#x2F;redis目录下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /redis/redis-6.2.6/redis.conf /app/redis/</span><br></pre></td></tr></table></figure>



<h4 id="（4）修改-redis-conf-文件"><a href="#（4）修改-redis-conf-文件" class="headerlink" title="（4）修改 redis.conf 文件"></a>（4）修改 redis.conf 文件</h4><blockquote>
<p><strong>开启 redis 验证    可选</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">requirepass foobared</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>注释掉</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1 -::1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>将 daemonize yes 注释起来或者 daemonize no设置，因为该配置和docker run 中- d 参数冲突，会导致容器一直启动失败</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>开启redis数据持久化  appendonly yes  可选</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure>



<h4 id="（5）使用-Redis6-2-6-镜像创建容器（也叫运行镜像）"><a href="#（5）使用-Redis6-2-6-镜像创建容器（也叫运行镜像）" class="headerlink" title="（5）使用 Redis6.2.6 镜像创建容器（也叫运行镜像）"></a>（5）使用 Redis6.2.6 镜像创建容器（也叫运行镜像）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.2.6 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="（6）测试"><a href="#（6）测试" class="headerlink" title="（6）测试"></a>（6）测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器是否创建成功</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部测试 redis 命令</span></span><br><span class="line">docker exec -it myr3 /bin/bash</span><br><span class="line"></span><br><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">set k1 v1</span><br><span class="line"></span><br><span class="line">get k1</span><br></pre></td></tr></table></figure>



<h4 id="（7）证明-Docker-启动使用了我们自己指定的配置文件"><a href="#（7）证明-Docker-启动使用了我们自己指定的配置文件" class="headerlink" title="（7）证明 Docker 启动使用了我们自己指定的配置文件"></a>（7）证明 Docker 启动使用了我们自己指定的配置文件</h4><blockquote>
<p><strong>修改宿主机下&#x2F;app&#x2F;redis里的 redis.conf 文件，修改 databases 10</strong></p>
</blockquote>
<h4 id="（8）测试"><a href="#（8）测试" class="headerlink" title="（8）测试"></a>（8）测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart myr3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动成功没有</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec -it myr3 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 redis</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试命令</span></span><br><span class="line">127.0.0.1:6379&gt; select 15</span><br><span class="line">(error) ERR DB index is out of range</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明 Docker 启动使用了我们自己指定的配置文件</span></span><br></pre></td></tr></table></figure>



<h1><center>高级篇</center></h1>



<h2 id="Docker-复制安装详说"><a href="#Docker-复制安装详说" class="headerlink" title="Docker 复制安装详说"></a>Docker 复制安装详说</h2><h3 id="MySQL-主从搭建"><a href="#MySQL-主从搭建" class="headerlink" title="MySQL 主从搭建"></a>MySQL 主从搭建</h3><h4 id="（1）新建主服务器容器实例-3307"><a href="#（1）新建主服务器容器实例-3307" class="headerlink" title="（1）新建主服务器容器实例 3307"></a>（1）新建主服务器容器实例 3307</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 Docker hub 上拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建容器实例</span></span><br><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>



<h4 id="（2）进入-x2F-mydata-x2F-mysql-master-x2F-conf目录下新建my-cnf"><a href="#（2）进入-x2F-mydata-x2F-mysql-master-x2F-conf目录下新建my-cnf" class="headerlink" title="（2）进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf"></a>（2）进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata/mysql-master/conf</span><br><span class="line"></span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class="line">server_id=101 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定不需要同步的数据库名称</span></span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 开启二进制日志功能</span></span></span><br><span class="line">log-bin=mall-mysql-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>



<h4 id="（3）修改完配置后重启-master-实例"><a href="#（3）修改完配置后重启-master-实例" class="headerlink" title="（3）修改完配置后重启 master 实例"></a>（3）修改完配置后重启 master 实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>



<h4 id="（4）进入-mysql-master-容器"><a href="#（4）进入-mysql-master-容器" class="headerlink" title="（4）进入 mysql-master 容器"></a>（4）进入 mysql-master 容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker exec -it mysql-master /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 MySQL 密码为 root</span></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>



<h4 id="（5）master-容器实例内创建数据同步用户"><a href="#（5）master-容器实例内创建数据同步用户" class="headerlink" title="（5）master 容器实例内创建数据同步用户"></a>（5）master 容器实例内创建数据同步用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="（6）新建从服务器实例-3308"><a href="#（6）新建从服务器实例-3308" class="headerlink" title="（6）新建从服务器实例 3308"></a>（6）新建从服务器实例 3308</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>



<h4 id="（7）进入-x2F-mydata-x2F-mysql-slave-x2F-conf目录下新建my-cnf"><a href="#（7）进入-x2F-mydata-x2F-mysql-slave-x2F-conf目录下新建my-cnf" class="headerlink" title="（7）进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf"></a>（7）进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata/mysql-slave/conf</span><br><span class="line"></span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class="line">server_id=102</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定不需要同步的数据库名称</span></span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span></span><br><span class="line">log-bin=mall-mysql-slave1-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># relay_log配置中继日志</span></span></span><br><span class="line">relay_log=mall-mysql-relay-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># slave设置为只读（具有super权限的用户除外）</span></span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>



<h4 id="（8）修改完配置后重启-slave-实例"><a href="#（8）修改完配置后重启-slave-实例" class="headerlink" title="（8）修改完配置后重启 slave 实例"></a>（8）修改完配置后重启 slave 实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>



<h4 id="（9）在主数据库中查看主从同步状态"><a href="#（9）在主数据库中查看主从同步状态" class="headerlink" title="（9）在主数据库中查看主从同步状态"></a>（9）在主数据库中查看主从同步状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File                  | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mall-mysql-bin.000001 |      617 |              | mysql            |                   |</span><br><span class="line">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h4 id="（10）进入mysql-slave容器"><a href="#（10）进入mysql-slave容器" class="headerlink" title="（10）进入mysql-slave容器"></a>（10）进入mysql-slave容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker exec -it mysql-slave /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 MySQL 密码为 root</span></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>



<h4 id="（11）在从数据库中配置主从复制"><a href="#（11）在从数据库中配置主从复制" class="headerlink" title="（11）在从数据库中配置主从复制"></a>（11）在从数据库中配置主从复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&#x27;宿主机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>主从复制命令参数说明：</strong></p>
<p><strong>master_host：主数据库的IP地址；</strong></p>
<p><strong>master_port：主数据库的运行端口；</strong></p>
<p><strong>master_user：在主数据库创建的用于同步数据的用户账号；</strong></p>
<p><strong>master_password：在主数据库创建的用于同步数据的用户密码；</strong></p>
<p><strong>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</strong></p>
<p><strong>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</strong></p>
<p><strong>master_connect_retry：连接失败重试的时间间隔，单位为秒。</strong></p>
</blockquote>
<p><strong>最终执行命令为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&#x27;120.78.11.141&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure>



<h4 id="（12）在从数据库中查看主从同步状态"><a href="#（12）在从数据库中查看主从同步状态" class="headerlink" title="（12）在从数据库中查看主从同步状态"></a>（12）在从数据库中查看主从同步状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/33.png" alt="33"></p>
<h4 id="（13）在从服务器中开启主从同步"><a href="#（13）在从服务器中开启主从同步" class="headerlink" title="（13）在从服务器中开启主从同步"></a>（13）在从服务器中开启主从同步</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>



<h4 id="（14）查看从数据库状态发现已同步"><a href="#（14）查看从数据库状态发现已同步" class="headerlink" title="（14）查看从数据库状态发现已同步"></a>（14）查看从数据库状态发现已同步</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/34.png" alt="34"></p>
<h4 id="（15）主从复制测试"><a href="#（15）主从复制测试" class="headerlink" title="（15）主从复制测试"></a>（15）主从复制测试</h4><p><strong>主机新建库-使用库-新建表-插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database db01;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use db01;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table t1</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt;     name varchar(20)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values (1,&#x27;zs&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; ;</span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values (1,&#x27;zs&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | zs   |</span><br><span class="line">|    1 | zs   |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>从机使用库查看记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use db01;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | zs   |</span><br><span class="line">|    1 | zs   |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="安装-Redis-集群（大厂面试题第四季-分布式存储案例真题）"><a href="#安装-Redis-集群（大厂面试题第四季-分布式存储案例真题）" class="headerlink" title="安装 Redis 集群（大厂面试题第四季-分布式存储案例真题）"></a>安装 Redis 集群（大厂面试题第四季-分布式存储案例真题）</h3><h4 id="cluster（集群）模式-Docker-版哈希槽分区进行亿级数据存储"><a href="#cluster（集群）模式-Docker-版哈希槽分区进行亿级数据存储" class="headerlink" title="cluster（集群）模式-Docker 版哈希槽分区进行亿级数据存储"></a>cluster（集群）模式-Docker 版哈希槽分区进行亿级数据存储</h4><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><blockquote>
<p><strong>问题：1~2亿条数据需要缓存，请问如何设计这个存储案例？</strong></p>
<p><strong>回答：单机单台100%不可能，肯定是分布式存储，用 Redis 如何落地？</strong></p>
<p><strong>上述问题阿里P6~P7工程案例和场景设计类必考题目，一般业界有三种解决方案。</strong></p>
</blockquote>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>1、哈希取余分区</strong></p>
<blockquote>
<p><strong>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：</strong><br><strong>hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</strong></p>
<p><strong>优点：</strong><br><strong>简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</strong></p>
<p><strong>缺点：</strong><br><strong>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</strong><br><strong>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/35.png" alt="35"></p>
<p><strong>2、一致性哈希算法分区</strong></p>
<p><strong>一致性哈希算法分区是什么？</strong></p>
<blockquote>
<p><strong>一致性Hash算法背景</strong></p>
<p><strong>一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决</strong></p>
<p><strong>分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了。</strong></p>
</blockquote>
<p><strong>能干嘛？</strong></p>
<blockquote>
<p><strong>提出一致性 Hash 解决方案。</strong></p>
<p><strong>目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。</strong></p>
</blockquote>
<p><strong>三大步骤</strong></p>
<p><strong>（1）算法构建一致性哈希环</strong></p>
<blockquote>
<p><strong>一致性哈希环</strong></p>
<p><strong>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。</strong></p>
<p><strong>它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/36.png" alt="36"></p>
</blockquote>
<p><strong>（2）服务器 IP 节点映射</strong></p>
<blockquote>
<p><strong>节点映射</strong></p>
<p><strong>将集群中各个IP节点映射到环上的某一个位置。</strong></p>
<p><strong>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下：</strong>  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/37.png" alt="37"></p>
</blockquote>
<p><strong>（3）key 落到服务器的落键规则</strong></p>
<blockquote>
<p><strong>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</strong></p>
<p><strong>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/38.png" alt="38"></p>
</blockquote>
<p><strong>优点</strong></p>
<p><strong>一致性哈希算法的容错性</strong></p>
<blockquote>
<p><strong>容错性</strong></p>
<p><strong>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/39.png" alt="39"></p>
</blockquote>
<p><strong>一致性哈希算法的拓展性</strong></p>
<blockquote>
<p> <strong>扩展性</strong></p>
<p> <strong>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</strong></p>
<p> <strong>不会导致hash取余全部数据重新洗牌。</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/40.png" alt="40"></p>
</blockquote>
<p><strong>缺点</strong></p>
<p><strong>一致性哈希算法的数据倾斜问题</strong></p>
<blockquote>
<p><strong>Hash环的数据倾斜问题</strong></p>
<p><strong>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，</strong></p>
<p><strong>例如系统中只有两台服务器：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/41.png" alt="41"></p>
</blockquote>
<p><strong>小总结</strong></p>
<blockquote>
<p><strong>为了在节点数目发生改变时尽可能少的迁移数据</strong></p>
<p><strong>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。</strong></p>
<p><strong>而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。</strong>  </p>
<hr>
<p><strong>优点</strong></p>
<p><strong>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</strong></p>
<hr>
<p><strong>缺点</strong> </p>
<p><strong>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</strong></p>
</blockquote>
<p><strong>3、哈希槽分区</strong></p>
<p><strong>为什么出现？</strong></p>
<blockquote>
<p><strong>哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。</strong></p>
</blockquote>
<p><strong>能干什么？</strong></p>
<blockquote>
<p><strong>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/42.png" alt="42"></p>
<p><strong>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</strong></p>
<p><strong>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</strong></p>
</blockquote>
<p> <strong>多少个hash槽</strong></p>
<blockquote>
<p><strong>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</strong></p>
</blockquote>
<h4 id="开打步骤"><a href="#开打步骤" class="headerlink" title="开打步骤"></a>开打步骤</h4><h5 id="3主3从-Redis-集群配置"><a href="#3主3从-Redis-集群配置" class="headerlink" title="3主3从 Redis 集群配置"></a>3主3从 Redis 集群配置</h5><p><strong>（1）关闭防火墙+启动Docker后台服务</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入/bin目录</span></span><br><span class="line">cd /bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 docker</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>



<p><strong>（2）新建6个Docker容器Redis实例</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure>

<p><strong>如果运行成功，效果如下：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/43.png" alt="43"></p>
<p><strong>命令分步解释：</strong></p>
<blockquote>
<p><strong>创建并运行 Docker 容器实例</strong><br><strong>docker run</strong></p>
<p><strong>容器名字</strong><br><strong>– name redis-node 6</strong></p>
<p><strong>使用宿主机的 IP 和 端口，默认</strong><br><strong>–net host</strong></p>
<p><strong>获取宿主机 root 用户权限</strong><br><strong>–privileged&#x3D;true</strong></p>
<p><strong>容器卷，宿主机地址:docker 内部地址</strong><br><strong>-v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-6:&#x2F;data</strong></p>
<p><strong>redis 镜像和版本号</strong><br><strong>redis:6.0.8</strong></p>
<p><strong>开启 Redis 集群</strong><br><strong>–cluster-enable yes</strong></p>
<p><strong>开启持久化</strong><br><strong>–appendonly yes</strong></p>
<p><strong>Redis 端口号</strong><br><strong>–port 6386</strong></p>
</blockquote>
<p><strong>（3）进入容器Redis-node-1并为6台机器构建集群关系</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意，进入 docker 容器后才能执行一下命令，且注意自己的真实IP地址（需要开放对应端口）</strong></p>
<p><strong>特别注意：需要开放集群的所有端口+10000的端口，及其 6379</strong></p>
<p><strong>比如：6381，对应开放端口就是16381</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/46.png" alt="46"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 120.78.11.141:6381 120.78.11.141:6382 120.78.11.141:6383 120.78.11.141:6384 120.78.11.141:6385 120.78.11.141:6386 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>–cluster-replicas 1 表示为每个master创建一个slave节点</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/44.png" alt="44"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/45.png" alt="45"></p>
<p><strong>（4）链接进入6381作为切入点，查看集群状态</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381</span><br><span class="line"></span><br><span class="line">cluster info</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/47.png" alt="47"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/Docker/48.png" alt="48"></p>
<h5 id="主从容错切换迁移案例"><a href="#主从容错切换迁移案例" class="headerlink" title="主从容错切换迁移案例"></a>主从容错切换迁移案例</h5><p><strong>数据读写存储</strong></p>
<p><strong>容错切换迁移</strong></p>
<h5 id="主从扩容案例"><a href="#主从扩容案例" class="headerlink" title="主从扩容案例"></a>主从扩容案例</h5><h5 id="主从缩容案例"><a href="#主从缩容案例" class="headerlink" title="主从缩容案例"></a>主从缩容案例</h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">枯木逢春</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://huang-666.github.io/2022/05/07/Docker/">https://huang-666.github.io/2022/05/07/Docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huang-666.github.io" target="_blank">枯木逢春夏秋冬</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/26/SpringSecurity/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringSecurity</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/05/Redis/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/头像.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">枯木逢春</div><div class="author-info__description">人生就像一盒巧克力，你永远不知道下一颗会是什么味道</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huang-666/"><i class="fab fa-github"></i><span>跟我来</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人在风中 聚散不由我</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">Docker 为什么出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E7%90%86%E5%BF%B5%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">Docker 理念概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">Docker 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.4.</span> <span class="toc-text">传统虚拟机和容器的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">容器发展简史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">传统虚拟机技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.4.2.1.</span> <span class="toc-text">传统虚拟机的缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">容器虚拟化技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E8%83%BD%E5%B9%B2%E5%98%9B%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.5.</span> <span class="toc-text">Docker 能干嘛能解决什么问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E8%81%8C%E7%BA%A7%E5%8F%98%E5%8C%96"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">技术职级变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91-x2F-%E8%BF%90%E7%BB%B4%EF%BC%88DevOps%EF%BC%89%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">开发&#x2F;运维（DevOps）新一代开发工程师</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">Docker 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E4%BC%81%E4%B8%9A%E5%9C%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">哪些企业在使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82"><span class="toc-number">2.2.1.</span> <span class="toc-text">1、操作系统要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.2.</span> <span class="toc-text">2、卸载旧版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85gcc%E7%9B%B8%E5%85%B3"><span class="toc-number">2.2.3.</span> <span class="toc-text">3、安装gcc相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AE%89%E8%A3%85%E9%9C%80%E8%A6%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">2.2.4.</span> <span class="toc-text">4、安装需要的软件包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%AE%BE%E7%BD%AEstable%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">2.2.5.</span> <span class="toc-text">5、设置stable镜像仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9B%B4%E6%96%B0yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">6、更新yum软件包索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%AE%89%E8%A3%85DOCKER-CE"><span class="toc-number">2.2.7.</span> <span class="toc-text">7、安装DOCKER CE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%90%AF%E5%8A%A8docker"><span class="toc-number">2.2.8.</span> <span class="toc-text">8、启动docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E9%87%8D%E5%90%AFdocker"><span class="toc-number">2.2.9.</span> <span class="toc-text">9、重启docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.10.</span> <span class="toc-text">10、测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.2.11.</span> <span class="toc-text">11、卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">2.2.12.</span> <span class="toc-text">12、阿里云镜像加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Docker-%E4%BC%9A%E6%AF%94-VM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB"><span class="toc-number">2.3.</span> <span class="toc-text">为什么 Docker 会比 VM 虚拟机快</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">底层原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">Docker 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.1.</span> <span class="toc-text">帮助启动类命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%90%AF%E5%8A%A8docker"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">（1）启动docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%81%9C%E6%AD%A2docker"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">（2）停止docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%87%8D%E5%90%AFdocker"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">（3）重启docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9F%A5%E7%9C%8Bdocker-%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">（4）查看docker 状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">（5）开机启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9F%A5%E7%9C%8Bdocker-%E6%A6%82%E8%A6%81%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.1.6.</span> <span class="toc-text">（6）查看docker 概要信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E6%9F%A5%E7%9C%8Bdocker-%E6%80%BB%E4%BD%93%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">2.4.1.7.</span> <span class="toc-text">（7）查看docker 总体帮助文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%9F%A5%E7%9C%8Bdocker-%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">2.4.1.8.</span> <span class="toc-text">（8）查看docker 命令帮助文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.2.</span> <span class="toc-text">镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">（1）列出本地主机上的镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BB%8EDocker-Hub-%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">（2）从Docker Hub 查找镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BB%8E%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8B%89%E5%8F%96%E6%88%96%E8%80%85%E6%9B%B4%E6%96%B0%E6%8C%87%E5%AE%9A%E9%95%9C%E5%83%8F"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">（3）从镜像仓库中拉取或者更新指定镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F-x2F-%E5%AE%B9%E5%99%A8-x2F-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%89%80%E5%8D%A0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">（4）查看镜像&#x2F;容器&#x2F;数据卷所占的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%95%9C%E5%83%8F"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">（5） 删除本地一个或多个镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%95%9C%E5%83%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">虚拟镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">虚拟镜像是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.4.</span> <span class="toc-text">容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">（1）创建一个新的容器并运行一个命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">（2）列出当前所有正在运行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">（3）退出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%90%AF%E5%8A%A8%E5%B7%B2%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">（4）启动已停止运行的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">（5）重启容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.6.</span> <span class="toc-text">（6）停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.7.</span> <span class="toc-text">（7）强制停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E5%88%A0%E9%99%A4%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.8.</span> <span class="toc-text">（8）删除已停止的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.4.4.9.</span> <span class="toc-text">（9）一次性删除多个容器实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">2.4.4.10.</span> <span class="toc-text">（10）启动守护式容器（后台服务器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">2.4.4.11.</span> <span class="toc-text">（11）查看容器日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.4.4.12.</span> <span class="toc-text">（12）查看容器内运行的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">2.4.4.13.</span> <span class="toc-text">（13）查看容器内部细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92"><span class="toc-number">2.4.4.14.</span> <span class="toc-text">（14）进入正在运行的容器并以命令行交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A"><span class="toc-number">2.4.4.15.</span> <span class="toc-text">（15）从容器内拷贝文件到主机上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.4.16.</span> <span class="toc-text">（16）导入和导出容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.5.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F"><span class="toc-number">2.5.</span> <span class="toc-text">Docker 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.5.1.</span> <span class="toc-text">镜像是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">分层的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionFS%EF%BC%88%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">2.5.3.</span> <span class="toc-text">UnionFS（联合文件系统）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.4.</span> <span class="toc-text">Docker 镜像加载原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Docker-%E9%95%9C%E5%83%8F%E8%A6%81%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%91%A2"><span class="toc-number">2.5.5.</span> <span class="toc-text">为什么 Docker 镜像要采用这种分层结构呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.6.</span> <span class="toc-text">重点理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F-commit-%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B"><span class="toc-number">2.5.7.</span> <span class="toc-text">Docker 镜像 commit 操作案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.5.8.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">2.6.</span> <span class="toc-text">本地镜像发布到阿里云</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">本地镜像发布到阿里云流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">（1）创建仓库镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">（2）将本地镜像推送到阿里云</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">从阿里云镜像仓库拉取镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93"><span class="toc-number">2.7.</span> <span class="toc-text">本地镜像发布到私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93"><span class="toc-number">2.7.1.</span> <span class="toc-text">将本地镜像推送到私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F-Docker-Registry"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">1、下载镜像 Docker Registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%BF%90%E8%A1%8C%E7%A7%81%E6%9C%89%E5%BA%93-Registry%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%9C%AC%E5%9C%B0%E6%9C%89%E4%B8%AA%E7%A7%81%E6%9C%89-Docker-hub"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">2、运行私有库 Registry，相当于本地有个私有 Docker hub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E9%95%9C%E5%83%8F%EF%BC%8Cubuntu-%E5%AE%89%E8%A3%85-ifconfig-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">3、案例演示创建一个新镜像，ubuntu 安装 ifconfig 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81curl-%E9%AA%8C%E8%AF%81%E7%A7%81%E6%9C%8D%E5%BA%93%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E9%95%9C%E5%83%8F"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">4、curl 验证私服库上有什么镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%B0%86%E6%96%B0%E9%95%9C%E5%83%8F-huangubuntu2-0-%E4%BF%AE%E6%94%B9%E7%AC%A6%E5%90%88%E7%A7%81%E6%9C%8D%E8%A7%84%E8%8C%83%E7%9A%84-Tag"><span class="toc-number">2.7.1.5.</span> <span class="toc-text">5、将新镜像 huangubuntu2.0 修改符合私服规范的 Tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E4%B9%8B%E6%94%AF%E6%8C%81-http"><span class="toc-number">2.7.1.6.</span> <span class="toc-text">6、修改配置文件使之支持 http</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81push-%E6%8E%A8%E9%80%81%E5%88%B0%E7%A7%81%E6%9C%8D%E5%BA%93"><span class="toc-number">2.7.1.7.</span> <span class="toc-text">7、push 推送到私服库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81curl-%E9%AA%8C%E8%AF%81%E7%A7%81%E6%9C%8D%E5%BA%93%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E9%95%9C%E5%83%8F"><span class="toc-number">2.7.1.8.</span> <span class="toc-text">8、curl 验证私服库上有什么镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81pull-%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%B9%B6%E8%BF%90%E8%A1%8C"><span class="toc-number">2.7.1.9.</span> <span class="toc-text">9、pull 到本地并运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">2.8.</span> <span class="toc-text">Docker 容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B8%A9%E5%9D%91"><span class="toc-number">2.8.1.</span> <span class="toc-text">踩坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.8.2.</span> <span class="toc-text">Docker 容器数据卷是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.8.3.</span> <span class="toc-text">运行一个带有容器卷存储功能的容器实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88"><span class="toc-number">2.8.4.</span> <span class="toc-text">Docker 容器数据卷能干什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%A1%88%E4%BE%8B"><span class="toc-number">2.8.5.</span> <span class="toc-text">容器数据卷案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%BF%E4%B8%BB-VS-%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="toc-number">2.8.5.1.</span> <span class="toc-text">1、宿主 VS 容器之间映射添加容器卷</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%9B%B4%E6%8E%A5%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0"><span class="toc-number">2.8.5.1.1.</span> <span class="toc-text">（1）直接命令添加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%98%AF%E5%90%A6%E6%8C%82%E8%BD%BD%E6%88%90%E5%8A%9F"><span class="toc-number">2.8.5.1.2.</span> <span class="toc-text">（2）查看数据卷是否挂载成功</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">2.8.5.1.3.</span> <span class="toc-text">（3）容器和宿主机之间数据共享</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99%E6%98%A0%E5%B0%84%E6%B7%BB%E5%8A%A0%E8%AF%B4%E6%98%8E"><span class="toc-number">2.8.5.2.</span> <span class="toc-text">2、读写规则映射添加说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">2.8.5.2.1.</span> <span class="toc-text">读写（默认）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB"><span class="toc-number">2.8.5.2.2.</span> <span class="toc-text">只读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8D%B7%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-number">2.8.5.3.</span> <span class="toc-text">3、卷的继承和共享</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AE%B9%E5%99%A81%E5%AE%8C%E6%88%90%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">2.8.5.3.1.</span> <span class="toc-text">（1）容器1完成和宿主机的映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%B9%E5%99%A82%E7%BB%A7%E6%89%BF%E5%AE%B9%E5%99%A81%E7%9A%84%E5%8D%B7%E8%A7%84%E5%88%99"><span class="toc-number">2.8.5.3.2.</span> <span class="toc-text">（2）容器2继承容器1的卷规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%B8%B8%E8%A7%84%E5%AE%89%E8%A3%85%E7%AE%80%E4%BB%8B"><span class="toc-number">2.9.</span> <span class="toc-text">Docker 常规安装简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.9.1.</span> <span class="toc-text">总体步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">（1）搜索镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">（2）拉取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F"><span class="toc-number">2.9.1.3.</span> <span class="toc-text">（3）查看镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%90%AF%E5%8A%A8%E9%95%9C%E5%83%8F%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-number">2.9.1.4.</span> <span class="toc-text">（4）启动镜像（服务端口映射）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">2.9.1.5.</span> <span class="toc-text">（5）停止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E7%A7%BB%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">2.9.1.6.</span> <span class="toc-text">（6）移除容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat-%E5%AE%89%E8%A3%85"><span class="toc-number">2.9.2.</span> <span class="toc-text">Tomcat 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Docker-hub-%E4%B8%8A%E9%9D%A2%E6%9F%A5%E6%89%BE-Tomcat-%E9%95%9C%E5%83%8F"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">（1）Docker hub 上面查找 Tomcat 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BB%8E-Docker-hub-%E4%B8%8A%E6%8B%89%E5%8F%96-Tomcat-%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">（2）从 Docker hub 上拉取 Tomcat 镜像到本地</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89docker-images-%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%9C%89%E6%8B%89%E5%8F%96%E5%88%B0-Tomcat"><span class="toc-number">2.9.2.3.</span> <span class="toc-text">（3）docker images 查看是否有拉取到 Tomcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8-Tomcat-%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%EF%BC%88%E4%B9%9F%E5%8F%AB%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F%EF%BC%89"><span class="toc-number">2.9.2.4.</span> <span class="toc-text">（4）使用 Tomcat 镜像创建容器实例（也叫运行镜像）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%AE%BF%E9%97%AE-Tomcat-%E9%A6%96%E9%A1%B5"><span class="toc-number">2.9.2.5.</span> <span class="toc-text">（5）访问 Tomcat 首页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%85%8D%E4%BF%AE%E6%94%B9%E7%89%88%E8%AF%B4%E6%98%8E"><span class="toc-number">2.9.2.6.</span> <span class="toc-text">（6）免修改版说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql-%E5%AE%89%E8%A3%85"><span class="toc-number">2.9.3.</span> <span class="toc-text">Mysql 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Docker-hub-%E4%B8%8A%E9%9D%A2%E6%9F%A5%E6%89%BE-MySQL-%E9%95%9C%E5%83%8F"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">（1）Docker hub 上面查找 MySQL 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BB%8E-Docker-hub-%E4%B8%8A%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9F%E5%99%A8%EF%BC%89%E6%8B%89%E5%8F%96-MySQL-%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%A0%87%E7%AD%BE%E4%B8%BA5-7"><span class="toc-number">2.9.3.2.</span> <span class="toc-text">（2）从 Docker hub 上（阿里云加速器）拉取 MySQL 镜像到本地标签为5.7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8-MySQL5-7-%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B9%9F%E5%8F%AB%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F%EF%BC%89"><span class="toc-number">2.9.3.3.</span> <span class="toc-text">（3）使用 MySQL5.7 镜像创建容器（也叫运行镜像）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-number">2.9.3.3.1.</span> <span class="toc-text">简单版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%89%88"><span class="toc-number">2.9.3.3.2.</span> <span class="toc-text">实战版</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">2.9.3.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%AE%89%E8%A3%85"><span class="toc-number">2.9.4.</span> <span class="toc-text">Redis 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8E-Docker-hub%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9F%E5%99%A8%EF%BC%89%E6%8B%89%E5%8F%96-Redis-%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%A0%87%E7%AD%BE%E4%B8%BA6-2-6"><span class="toc-number">2.9.4.1.</span> <span class="toc-text">（1）从 Docker hub（阿里云加速器）拉取 Redis 镜像到本地标签为6.2.6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%8D-Centros-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8B%E6%96%B0%E5%BB%BA%E7%9B%AE%E5%BD%95-x2F-app-x2F-redis"><span class="toc-number">2.9.4.2.</span> <span class="toc-text">（2）再 Centros 宿主机下新建目录&#x2F;app&#x2F;redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B0%86%E4%B8%80%E4%B8%AA-Redis-conf-%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF%E6%8B%B7%E8%B4%9D%E8%BF%9B-x2F-app-x2F-redis%E7%9B%AE%E5%BD%95%E4%B8%8B"><span class="toc-number">2.9.4.3.</span> <span class="toc-text">（3）将一个 Redis.conf 文件模板拷贝进&#x2F;app&#x2F;redis目录下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BF%AE%E6%94%B9-redis-conf-%E6%96%87%E4%BB%B6"><span class="toc-number">2.9.4.4.</span> <span class="toc-text">（4）修改 redis.conf 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%BD%BF%E7%94%A8-Redis6-2-6-%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B9%9F%E5%8F%AB%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F%EF%BC%89"><span class="toc-number">2.9.4.5.</span> <span class="toc-text">（5）使用 Redis6.2.6 镜像创建容器（也叫运行镜像）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="toc-number">2.9.4.6.</span> <span class="toc-text">（6）测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E8%AF%81%E6%98%8E-Docker-%E5%90%AF%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%BA%86%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E6%8C%87%E5%AE%9A%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.9.4.7.</span> <span class="toc-text">（7）证明 Docker 启动使用了我们自己指定的配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="toc-number">2.9.4.8.</span> <span class="toc-text">（8）测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">高级篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%A4%8D%E5%88%B6%E5%AE%89%E8%A3%85%E8%AF%A6%E8%AF%B4"><span class="toc-number">3.1.</span> <span class="toc-text">Docker 复制安装详说</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA"><span class="toc-number">3.1.1.</span> <span class="toc-text">MySQL 主从搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%B0%E5%BB%BA%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B-3307"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">（1）新建主服务器容器实例 3307</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BF%9B%E5%85%A5-x2F-mydata-x2F-mysql-master-x2F-conf%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BAmy-cnf"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">（2）进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BF%AE%E6%94%B9%E5%AE%8C%E9%85%8D%E7%BD%AE%E5%90%8E%E9%87%8D%E5%90%AF-master-%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">（3）修改完配置后重启 master 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%BF%9B%E5%85%A5-mysql-master-%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">（4）进入 mysql-master 容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89master-%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%86%85%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%94%A8%E6%88%B7"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">（5）master 容器实例内创建数据同步用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%96%B0%E5%BB%BA%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B-3308"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">（6）新建从服务器实例 3308</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E8%BF%9B%E5%85%A5-x2F-mydata-x2F-mysql-slave-x2F-conf%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BAmy-cnf"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">（7）进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E4%BF%AE%E6%94%B9%E5%AE%8C%E9%85%8D%E7%BD%AE%E5%90%8E%E9%87%8D%E5%90%AF-slave-%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.1.1.8.</span> <span class="toc-text">（8）修改完配置后重启 slave 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E5%9C%A8%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.1.9.</span> <span class="toc-text">（9）在主数据库中查看主从同步状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E8%BF%9B%E5%85%A5mysql-slave%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.1.10.</span> <span class="toc-text">（10）进入mysql-slave容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E5%9C%A8%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.1.11.</span> <span class="toc-text">（11）在从数据库中配置主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89%E5%9C%A8%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.1.12.</span> <span class="toc-text">（12）在从数据库中查看主从同步状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89%E5%9C%A8%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E5%BC%80%E5%90%AF%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">3.1.1.13.</span> <span class="toc-text">（13）在从服务器中开启主从同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E6%9F%A5%E7%9C%8B%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8A%B6%E6%80%81%E5%8F%91%E7%8E%B0%E5%B7%B2%E5%90%8C%E6%AD%A5"><span class="toc-number">3.1.1.14.</span> <span class="toc-text">（14）查看从数据库状态发现已同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.1.15.</span> <span class="toc-text">（15）主从复制测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Redis-%E9%9B%86%E7%BE%A4%EF%BC%88%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%AD%A3-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E6%A1%88%E4%BE%8B%E7%9C%9F%E9%A2%98%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">安装 Redis 集群（大厂面试题第四季-分布式存储案例真题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cluster%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89%E6%A8%A1%E5%BC%8F-Docker-%E7%89%88%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA%E8%BF%9B%E8%A1%8C%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">cluster（集群）模式-Docker 版哈希槽分区进行亿级数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%89%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">开打步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E4%B8%BB3%E4%BB%8E-Redis-%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">3主3从 Redis 集群配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E8%BF%81%E7%A7%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.2.2.2.</span> <span class="toc-text">主从容错切换迁移案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.2.2.3.</span> <span class="toc-text">主从扩容案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.2.2.4.</span> <span class="toc-text">主从缩容案例</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/26/SpringSecurity/" title="SpringSecurity"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity"/></a><div class="content"><a class="title" href="/2022/05/26/SpringSecurity/" title="SpringSecurity">SpringSecurity</a><time datetime="2022-05-26T13:45:02.000Z" title="发表于 2022-05-26 21:45:02">2022-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/07/Docker/" title="Docker"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2022/05/07/Docker/" title="Docker">Docker</a><time datetime="2022-05-07T13:40:56.000Z" title="发表于 2022-05-07 21:40:56">2022-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/Redis/" title="Redis"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2022/05/05/Redis/" title="Redis">Redis</a><time datetime="2022-05-05T12:46:11.000Z" title="发表于 2022-05-05 20:46:11">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/Shell/" title="Shell"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客其它页面顶部图.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shell"/></a><div class="content"><a class="title" href="/2022/05/05/Shell/" title="Shell">Shell</a><time datetime="2022-05-05T12:41:23.000Z" title="发表于 2022-05-05 20:41:23">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/04/%E6%AF%8F%E5%A4%A9%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98/" title="每天刷刷面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images-cloud-bed.oss-cn-shenzhen.aliyuncs.com/博客/博客封面图01.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="每天刷刷面试题"/></a><div class="content"><a class="title" href="/2022/05/04/%E6%AF%8F%E5%A4%A9%E4%B8%A4%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98/" title="每天刷刷面试题">每天刷刷面试题</a><time datetime="2022-05-04T08:59:40.000Z" title="发表于 2022-05-04 16:59:40">2022-05-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 枯木逢春</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://wap.miit.gov.cn/"><span>粤ICP备2022058168号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '9kteGLCuLEeg8brfuQA0KI28-gzGzoHsz',
      appKey: 'bhWod0MiYEyCCmXNlX4sd7Io',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://9kteGLCu.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '9kteGLCuLEeg8brfuQA0KI28-gzGzoHsz',
        "X-LC-Key": 'bhWod0MiYEyCCmXNlX4sd7Io',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="7414107066" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="/js/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="枯,木,逢,春" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":250},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>